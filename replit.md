# Momentum - The Replay Tracker

## Overview

Momentum is a gamified task and habit tracker that implements a unique "Replay" mechanic inspired by gaming. Instead of traditional habit streaks that break when missed, Momentum uses scheduled interval check-ins where missed tasks trigger a Replay Mode - offering users a chance to recover by completing a reduced target goal. The application helps users break down overwhelming goals into manageable micro-tasks with mandatory check-ins at custom intervals.

**Core Philosophy**: "Defeat is a Replay opportunity" - transforming missed tasks into recovery challenges rather than streak-breaking failures.

**Key Features**:
- Interval-based task tracking (duration or count metrics)
- Automatic check-in notifications when tasks become due
- Replay Mode with reduced targets after missed check-ins
- Gamified progress visualization with rings and streaks
- Dark-first design for reduced eye strain

## User Preferences

Preferred communication style: Simple, everyday language.

## System Architecture

### Frontend Architecture

**Technology Stack**:
- React 18 with TypeScript
- Vite as build tool and dev server
- Wouter for client-side routing
- TanStack Query (React Query) for server state management
- Framer Motion for animations
- Recharts for data visualization

**UI Component System**:
- shadcn/ui components (Radix UI primitives)
- Tailwind CSS for styling with custom design tokens
- Material Design foundations with gaming-inspired visualization
- Typography: Inter for UI, JetBrains Mono for timers/counters

**Design Principles**:
- Focus-driven minimalism - dashboard shows only essential active task
- Dark-first theme (high contrast with rich accent colors)
- Immediate visual feedback for all interactions
- Gaming psychology through progress rings, streaks, and scores

**State Management Pattern**:
- Server state via React Query with optimistic updates
- Local UI state via React hooks
- No global state management library (intentionally simple)
- 30-second polling for task updates to catch due check-ins

**Key Custom Hooks**:
- `useIntervalManager`: Monitors tasks for due check-ins, triggers notifications
- `useToast`: Toast notification system
- `useIsMobile`: Responsive breakpoint detection

### Backend Architecture

**Technology Stack**:
- Express.js server
- TypeScript throughout
- Drizzle ORM for database operations
- PostgreSQL database (via Neon serverless)

**API Design**:
- RESTful endpoints under `/api` prefix
- CRUD operations for tasks and check-ins
- Stats aggregation endpoints
- JSON request/response format

**Storage Layer**:
- Interface-based storage abstraction (`IStorage`)
- In-memory implementation for development (`MemStorage`)
- Production uses Drizzle ORM with PostgreSQL
- Schema defined in shared folder for type safety

**Database Schema**:
- `tasks` table: Core task configuration and state (name, category, metric type, target, interval, streak, replay mode flags)
- `check_ins` table: Historical check-in records (value, defeat/replay flags, timestamps)
- UUID primary keys generated by database
- Timestamps for created/checked-in tracking

**Business Logic**:
- Tasks have scheduled `nextCheckinAt` timestamps
- Check-ins can be marked as defeats or replays
- Replay mode triggers when check-in missed, reduces target by ~50%
- Streaks increment on successful check-ins, reset on defeats
- Stats calculated from check-in history (today/week/month totals, replay success rate)

### Component Architecture

**Page Components** (`/pages`):
- `Dashboard`: Active task display with progress ring, auto-shows check-in modals
- `Tasks`: Task list/grid with creation form
- `Stats`: Statistics and charts across all tasks

**Reusable Components** (`/components`):
- `ActiveTaskDisplay`: Large centered card with progress ring
- `CheckinModal`: Input form for recording task completion (success/defeat)
- `ReplayModal`: Confirmation dialog for entering Replay Mode
- `ProgressRing`: Circular progress visualization (SVG-based)
- `TaskCard`: Grid item showing task overview
- `TaskTimer`: Start/stop timer for duration-based tasks
- `MetricCard`: Stats display with icon and large number
- `MonthlyStats`: Bar chart for historical data

**Design System** (`/components/ui`):
- Complete shadcn/ui component library
- Customized with Tailwind config for brand colors
- Hover/active elevation states for interactive elements
- Consistent spacing scale (2/4/6/8 Tailwind units)

### Data Flow

1. **Task Creation**: Form → API POST → Database → Query invalidation → UI update
2. **Check-in Flow**: 
   - Interval manager detects due task
   - Modal auto-displays
   - User submits value
   - API creates check-in record
   - Task state updated (streak, next check-in time, replay flags)
   - Stats recalculated
3. **Replay Flow**:
   - Defeat triggers replay modal
   - User sets reduced target (default 50% of original)
   - Task enters replay mode with temporary target
   - Next successful check-in exits replay mode

### Routing

**Client Routes**:
- `/` - Dashboard (default active task view)
- `/tasks` - Task management page
- `/stats` - Statistics and charts

**API Routes**:
- `GET /api/tasks` - List all active tasks
- `GET /api/tasks/:id` - Get single task
- `POST /api/tasks` - Create new task
- `PATCH /api/tasks/:id` - Update task
- `DELETE /api/tasks/:id` - Soft delete (set isActive=false)
- `POST /api/check-ins` - Record check-in
- `GET /api/tasks/:id/stats` - Get task statistics
- `GET /api/stats` - Get global statistics

## External Dependencies

**Database**:
- PostgreSQL (via Neon serverless driver `@neondatabase/serverless`)
- Connection string via `DATABASE_URL` environment variable
- Drizzle ORM for migrations and queries

**UI Libraries**:
- Radix UI primitives (accordion, dialog, dropdown, etc.)
- Recharts for data visualization
- Framer Motion for animations
- Embla Carousel (installed but usage TBD)
- cmdk for command palette (installed but usage TBD)

**Development Tools**:
- Vite plugins for Replit integration (cartographer, dev banner, error modal)
- ESBuild for production server bundling
- TypeScript compiler for type checking

**Fonts**:
- Google Fonts: Inter (UI), JetBrains Mono (timers/numbers)

**Validation**:
- Zod for schema validation (integrated with Drizzle via `drizzle-zod`)
- Form validation via `@hookform/resolvers` and React Hook Form

**Session Management**:
- `connect-pg-simple` for PostgreSQL session store (installed, implementation pending)
- Express sessions for user state (if multi-user support added)

**Styling**:
- Tailwind CSS with PostCSS
- Custom theme with CSS variables for dark/light mode support
- `class-variance-authority` for component variant styling
- `clsx` and `tailwind-merge` for conditional class composition

**Date Handling**:
- `date-fns` for date manipulation and formatting